---
description: Guidelines for creating database migrations in Supabase
alwaysApply: false
---

# Database: Create migration

You're a Supabase expert in creating database migrations. Generate **high-quality migration scripts** that adhere to the following best practices:

## General Guidelines

1. **Use Transactional Migrations:**

   - Wrap migration scripts in transactions to ensure atomicity and rollback on failure.

2. **Idempotent Scripts:**

   - Ensure migrations can be run multiple times without causing unintended side effects.
   - Use `IF NOT EXISTS` or `IF EXISTS` clauses where appropriate.

3. **Version Control:**

   - Maintain a clear versioning system for migration files to track changes over time.
   - Use descriptive timestamps and names (e.g., `YYYYMMDDHHMMSS_description.sql`).

## Best Practices

1. **Descriptive Naming:**

   - Use clear and descriptive names for migration files to indicate their purpose.
   - Example: `20240115120000_add_user_bio_column.sql`

2. **Backward Compatibility:**

   - Design migrations to be backward compatible when possible to prevent breaking changes.
   - Provide both `up` and `down` migrations when applicable.

3. **Test Migrations:**

   - Thoroughly test migration scripts in a staging environment before applying them to production.
   - Test both the up and down migrations.

4. **Check Dependencies:**

   - Ensure any dependencies (tables, functions, etc.) exist before creating objects that reference them.

## Example Templates

### Simple Migration with Transaction

```sql
begin;

-- Add a new column to the users table
alter table public.users
add column if not exists bio text;

commit;
```

### Migration with Rollback

```sql
begin;

-- Create a new table
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  bio text,
  avatar_url text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Create indexes
create index if not exists profiles_created_at_idx on public.profiles(created_at);

-- Create updated_at trigger
create or replace function public.handle_updated_at()
returns trigger
language plpgsql
security invoker
set search_path = ''
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger profiles_updated_at
before update on public.profiles
for each row
execute function public.handle_updated_at();

commit;
```

### Migration with Conditional Logic

```sql
begin;

-- Only add column if it doesn't exist
do $$
begin
  if not exists (
    select 1 from information_schema.columns
    where table_schema = 'public'
    and table_name = 'users'
    and column_name = 'phone'
  ) then
    alter table public.users add column phone text;
  end if;
end $$;

commit;
```

### Data Migration

```sql
begin;

-- Migrate existing data
update public.users
set display_name = coalesce(first_name || ' ' || last_name, email)
where display_name is null;

-- Add constraint after data is migrated
alter table public.users
alter column display_name set not null;

commit;
```
