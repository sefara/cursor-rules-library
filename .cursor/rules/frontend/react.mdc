# React Frontend Development

## Component Patterns

### Functional Components with Hooks
```typescript
import { useState, useEffect } from 'react'

interface UserProps {
  userId: string
}

const UserProfile: React.FC<UserProps> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchUser(userId).then(data => {
      setUser(data)
      setLoading(false)
    })
  }, [userId])

  if (loading) return <div>Loading...</div>
  if (!user) return <div>User not found</div>

  return <div>{user.name}</div>
}
```

### Custom Hooks
```typescript
// useUser.ts
export function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [userId])

  return { user, loading, error }
}

// Usage
const { user, loading, error } = useUser(userId)
```

## State Management

### Local State
```typescript
const [count, setCount] = useState(0)
```

### Context API
```typescript
// UserContext.tsx
const UserContext = createContext<UserContextType | undefined>(undefined)

export function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  )
}

export function useUserContext() {
  const context = useContext(UserContext)
  if (!context) throw new Error('useUserContext must be used in UserProvider')
  return context
}
```

### Redux Toolkit (for complex state)
```typescript
// store.ts
import { configureStore } from '@reduxjs/toolkit'
import userSlice from './slices/userSlice'

export const store = configureStore({
  reducer: {
    user: userSlice,
  },
})

// Usage
const user = useSelector((state: RootState) => state.user.user)
const dispatch = useDispatch()
dispatch(setUser(newUser))
```

## Best Practices

### Component Structure
```typescript
// 1. Imports (external, internal, types, hooks)
import React, { useState } from 'react'
import { Button } from './Button'
import { User } from '../types'
import { useUser } from '../hooks/useUser'

// 2. Types/Interfaces
interface ComponentProps {
  userId: string
}

// 3. Component
export const Component: React.FC<ComponentProps> = ({ userId }) => {
  // 4. Hooks
  const { user } = useUser(userId)
  const [count, setCount] = useState(0)

  // 5. Handlers
  const handleClick = () => {
    setCount(prev => prev + 1)
  }

  // 6. Effects
  useEffect(() => {
    // Side effects
  }, [dependencies])

  // 7. Render
  return (
    <div>
      <Button onClick={handleClick}>Click me</Button>
    </div>
  )
}
```

### Performance Optimization

#### Memoization
```typescript
// Memoize expensive components
const ExpensiveComponent = memo(({ data }: Props) => {
  // Expensive rendering
})

// Memoize callbacks
const handleClick = useCallback(() => {
  // Handler logic
}, [dependencies])

// Memoize computed values
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data)
}, [data])
```

#### Code Splitting
```typescript
// Lazy load components
const LazyComponent = lazy(() => import('./LazyComponent'))

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  )
}
```

### Data Fetching

#### useEffect Pattern
```typescript
useEffect(() => {
  let cancelled = false
  
  async function fetchData() {
    try {
      const data = await api.getData()
      if (!cancelled) {
        setData(data)
      }
    } catch (error) {
      if (!cancelled) {
        setError(error)
      }
    }
  }
  
  fetchData()
  
  return () => {
    cancelled = true
  }
}, [dependencies])
```

#### React Query / TanStack Query
```typescript
import { useQuery, useMutation } from '@tanstack/react-query'

// Query
const { data, isLoading, error } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId),
  staleTime: 5 * 60 * 1000, // 5 minutes
})

// Mutation
const mutation = useMutation({
  mutationFn: updateUser,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['user'] })
  },
})
```

## Form Handling

### Controlled Components
```typescript
const [formData, setFormData] = useState({ name: '', email: '' })

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setFormData(prev => ({
    ...prev,
    [e.target.name]: e.target.value
  }))
}

return (
  <form onSubmit={handleSubmit}>
    <input
      name="name"
      value={formData.name}
      onChange={handleChange}
    />
  </form>
)
```

### React Hook Form
```typescript
import { useForm } from 'react-hook-form'

const { register, handleSubmit, formState: { errors } } = useForm()

return (
  <form onSubmit={handleSubmit(onSubmit)}>
    <input {...register('name', { required: true })} />
    {errors.name && <span>Name is required</span>}
  </form>
)
```

## Error Boundaries
```typescript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true }
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }
}
```

## Testing

### React Testing Library
```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import { UserProfile } from './UserProfile'

test('renders user name', () => {
  render(<UserProfile userId="123" />)
  expect(screen.getByText('John Doe')).toBeInTheDocument()
})

test('handles button click', () => {
  render(<UserProfile userId="123" />)
  const button = screen.getByRole('button')
  fireEvent.click(button)
  expect(screen.getByText('Clicked')).toBeInTheDocument()
})
```

## Best Practices Summary

1. **Functional Components**: Prefer functional components with hooks
2. **Custom Hooks**: Extract reusable logic into custom hooks
3. **State Management**: Use Context for simple state, Redux for complex
4. **Performance**: Memoize expensive operations, code split
5. **TypeScript**: Use TypeScript for type safety
6. **Testing**: Write tests for components
7. **Accessibility**: Use semantic HTML, ARIA attributes
8. **Error Handling**: Use Error Boundaries
